{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, Directive, Output, Input, NgModule } from '@angular/core';\nimport { _ as _resolveDirectionality, D as Directionality } from './directionality-9d44e426.mjs';\n\n/**\n * Directive to listen for changes of direction of part of the DOM.\n *\n * Provides itself as Directionality such that descendant directives only need to ever inject\n * Directionality to get the closest direction.\n */\nclass Dir {\n  /** Normalized direction that accounts for invalid/unsupported values. */\n  _dir = 'ltr';\n  /** Whether the `value` has been set to its initial value. */\n  _isInitialized = false;\n  /** Direction as passed in by the consumer. */\n  _rawDir;\n  /** Event emitted when the direction changes. */\n  change = new EventEmitter();\n  /** @docs-private */\n  get dir() {\n    return this._dir;\n  }\n  set dir(value) {\n    const previousValue = this._dir;\n    // Note: `_resolveDirectionality` resolves the language based on the browser's language,\n    // whereas the browser does it based on the content of the element. Since doing so based\n    // on the content can be expensive, for now we're doing the simpler matching.\n    this._dir = _resolveDirectionality(value);\n    this._rawDir = value;\n    if (previousValue !== this._dir && this._isInitialized) {\n      this.change.emit(this._dir);\n    }\n  }\n  /** Current layout direction of the element. */\n  get value() {\n    return this.dir;\n  }\n  /** Initialize once default value has been set. */\n  ngAfterContentInit() {\n    this._isInitialized = true;\n  }\n  ngOnDestroy() {\n    this.change.complete();\n  }\n  static ɵfac = function Dir_Factory(t) {\n    return new (t || Dir)();\n  };\n  static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: Dir,\n    selectors: [[\"\", \"dir\", \"\"]],\n    hostVars: 1,\n    hostBindings: function Dir_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"dir\", ctx._rawDir);\n      }\n    },\n    inputs: {\n      dir: \"dir\"\n    },\n    outputs: {\n      change: \"dirChange\"\n    },\n    exportAs: [\"dir\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: Directionality,\n      useExisting: Dir\n    }])]\n  });\n}\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Dir, [{\n    type: Directive,\n    args: [{\n      selector: '[dir]',\n      providers: [{\n        provide: Directionality,\n        useExisting: Dir\n      }],\n      host: {\n        '[attr.dir]': '_rawDir'\n      },\n      exportAs: 'dir'\n    }]\n  }], null, {\n    change: [{\n      type: Output,\n      args: ['dirChange']\n    }],\n    dir: [{\n      type: Input\n    }]\n  });\n})();\nclass BidiModule {\n  static ɵfac = function BidiModule_Factory(t) {\n    return new (t || BidiModule)();\n  };\n  static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: BidiModule\n  });\n  static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n}\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(BidiModule, [{\n    type: NgModule,\n    args: [{\n      imports: [Dir],\n      exports: [Dir]\n    }]\n  }], null, null);\n})();\nexport { BidiModule as B, Dir as D };","map":{"version":3,"names":["i0","EventEmitter","Directive","Output","Input","NgModule","_","_resolveDirectionality","D","Directionality","Dir","_dir","_isInitialized","_rawDir","change","dir","value","previousValue","emit","ngAfterContentInit","ngOnDestroy","complete","ɵfac","ɵdir","provide","useExisting","type","args","selector","providers","host","exportAs","BidiModule","ɵmod","ɵinj","imports","exports","B"],"sources":["/home/ikram/node_modules/@angular/cdk/fesm2022/bidi-module-04c03e58.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { EventEmitter, Directive, Output, Input, NgModule } from '@angular/core';\nimport { _ as _resolveDirectionality, D as Directionality } from './directionality-9d44e426.mjs';\n\n/**\n * Directive to listen for changes of direction of part of the DOM.\n *\n * Provides itself as Directionality such that descendant directives only need to ever inject\n * Directionality to get the closest direction.\n */\nclass Dir {\n    /** Normalized direction that accounts for invalid/unsupported values. */\n    _dir = 'ltr';\n    /** Whether the `value` has been set to its initial value. */\n    _isInitialized = false;\n    /** Direction as passed in by the consumer. */\n    _rawDir;\n    /** Event emitted when the direction changes. */\n    change = new EventEmitter();\n    /** @docs-private */\n    get dir() {\n        return this._dir;\n    }\n    set dir(value) {\n        const previousValue = this._dir;\n        // Note: `_resolveDirectionality` resolves the language based on the browser's language,\n        // whereas the browser does it based on the content of the element. Since doing so based\n        // on the content can be expensive, for now we're doing the simpler matching.\n        this._dir = _resolveDirectionality(value);\n        this._rawDir = value;\n        if (previousValue !== this._dir && this._isInitialized) {\n            this.change.emit(this._dir);\n        }\n    }\n    /** Current layout direction of the element. */\n    get value() {\n        return this.dir;\n    }\n    /** Initialize once default value has been set. */\n    ngAfterContentInit() {\n        this._isInitialized = true;\n    }\n    ngOnDestroy() {\n        this.change.complete();\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.0\", ngImport: i0, type: Dir, deps: [], target: i0.ɵɵFactoryTarget.Directive });\n    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"19.2.0\", type: Dir, isStandalone: true, selector: \"[dir]\", inputs: { dir: \"dir\" }, outputs: { change: \"dirChange\" }, host: { properties: { \"attr.dir\": \"_rawDir\" } }, providers: [{ provide: Directionality, useExisting: Dir }], exportAs: [\"dir\"], ngImport: i0 });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.0\", ngImport: i0, type: Dir, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[dir]',\n                    providers: [{ provide: Directionality, useExisting: Dir }],\n                    host: { '[attr.dir]': '_rawDir' },\n                    exportAs: 'dir',\n                }]\n        }], propDecorators: { change: [{\n                type: Output,\n                args: ['dirChange']\n            }], dir: [{\n                type: Input\n            }] } });\n\nclass BidiModule {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.0\", ngImport: i0, type: BidiModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"19.2.0\", ngImport: i0, type: BidiModule, imports: [Dir], exports: [Dir] });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"19.2.0\", ngImport: i0, type: BidiModule });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.0\", ngImport: i0, type: BidiModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [Dir],\n                    exports: [Dir],\n                }]\n        }] });\n\nexport { BidiModule as B, Dir as D };\n"],"mappings":"AAAA,OAAO,KAAKA,EAAE,MAAM,eAAe;AACnC,SAASC,YAAY,EAAEC,SAAS,EAAEC,MAAM,EAAEC,KAAK,EAAEC,QAAQ,QAAQ,eAAe;AAChF,SAASC,CAAC,IAAIC,sBAAsB,EAAEC,CAAC,IAAIC,cAAc,QAAQ,+BAA+B;;AAEhG;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,GAAG,CAAC;EACN;EACAC,IAAI,GAAG,KAAK;EACZ;EACAC,cAAc,GAAG,KAAK;EACtB;EACAC,OAAO;EACP;EACAC,MAAM,GAAG,IAAIb,YAAY,EAAE;EAC3B;EACA,IAAIc,GAAG,GAAG;IACN,OAAO,IAAI,CAACJ,IAAI;EACpB;EACA,IAAII,GAAG,CAACC,KAAK,EAAE;IACX,MAAMC,aAAa,GAAG,IAAI,CAACN,IAAI;IAC/B;IACA;IACA;IACA,IAAI,CAACA,IAAI,GAAGJ,sBAAsB,CAACS,KAAK,CAAC;IACzC,IAAI,CAACH,OAAO,GAAGG,KAAK;IACpB,IAAIC,aAAa,KAAK,IAAI,CAACN,IAAI,IAAI,IAAI,CAACC,cAAc,EAAE;MACpD,IAAI,CAACE,MAAM,CAACI,IAAI,CAAC,IAAI,CAACP,IAAI,CAAC;IAC/B;EACJ;EACA;EACA,IAAIK,KAAK,GAAG;IACR,OAAO,IAAI,CAACD,GAAG;EACnB;EACA;EACAI,kBAAkB,GAAG;IACjB,IAAI,CAACP,cAAc,GAAG,IAAI;EAC9B;EACAQ,WAAW,GAAG;IACV,IAAI,CAACN,MAAM,CAACO,QAAQ,EAAE;EAC1B;EACA,OAAOC,IAAI;IAAA,iBAAwFZ,GAAG;EAAA;EACtG,OAAOa,IAAI,kBAD8EvB,EAAE;IAAA,MACJU,GAAG;IAAA;IAAA;IAAA;MAAA;QADDV,EAAE;MAAA;IAAA;IAAA;MAAA;IAAA;IAAA;MAAA;IAAA;IAAA;IAAA;IAAA,WAAFA,EAAE,oBAC8J,CAAC;MAAEwB,OAAO,EAAEf,cAAc;MAAEgB,WAAW,EAAEf;IAAI,CAAC,CAAC;EAAA;AAC5S;AACA;EAAA,mDAH6FV,EAAE,mBAGJU,GAAG,EAAc,CAAC;IACjGgB,IAAI,EAAExB,SAAS;IACfyB,IAAI,EAAE,CAAC;MACCC,QAAQ,EAAE,OAAO;MACjBC,SAAS,EAAE,CAAC;QAAEL,OAAO,EAAEf,cAAc;QAAEgB,WAAW,EAAEf;MAAI,CAAC,CAAC;MAC1DoB,IAAI,EAAE;QAAE,YAAY,EAAE;MAAU,CAAC;MACjCC,QAAQ,EAAE;IACd,CAAC;EACT,CAAC,CAAC,QAAkB;IAAEjB,MAAM,EAAE,CAAC;MACvBY,IAAI,EAAEvB,MAAM;MACZwB,IAAI,EAAE,CAAC,WAAW;IACtB,CAAC,CAAC;IAAEZ,GAAG,EAAE,CAAC;MACNW,IAAI,EAAEtB;IACV,CAAC;EAAE,CAAC;AAAA;AAEhB,MAAM4B,UAAU,CAAC;EACb,OAAOV,IAAI;IAAA,iBAAwFU,UAAU;EAAA;EAC7G,OAAOC,IAAI,kBApB8EjC,EAAE;IAAA,MAoBSgC;EAAU;EAC9G,OAAOE,IAAI,kBArB8ElC,EAAE;AAsB/F;AACA;EAAA,mDAvB6FA,EAAE,mBAuBJgC,UAAU,EAAc,CAAC;IACxGN,IAAI,EAAErB,QAAQ;IACdsB,IAAI,EAAE,CAAC;MACCQ,OAAO,EAAE,CAACzB,GAAG,CAAC;MACd0B,OAAO,EAAE,CAAC1B,GAAG;IACjB,CAAC;EACT,CAAC,CAAC;AAAA;AAEV,SAASsB,UAAU,IAAIK,CAAC,EAAE3B,GAAG,IAAIF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}